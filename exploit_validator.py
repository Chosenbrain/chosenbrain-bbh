import requests
import logging
import re

logger = logging.getLogger(__name__)

# Signatures of known vulnerable behaviors (e.g., reflected XSS, stack traces)
TRIGGERS = [
    r"<script>alert\(1\)</script>",
    r"SQL syntax.*MySQL",
    r"Warning:.*\bon line \d+",
    r"Exception.*?at .*?\(.*?\.java:\d+\)",
    r"you have an error in your sql syntax",
    r"ORA-\d+",
    r"XPathException",
    r"Stacktrace",
    r"bash: .* command not found",
    r"unexpected token.*",
]

def validate_exploit(url: str, payloads: list[str]) -> list[dict]:
    """
    Confirms if any payload causes a visible vulnerability.

    Args:
        url (str): Base URL to test.
        payloads (list): Injected URLs.

    Returns:
        List of dicts with vulnerable URLs and type of trigger found.
    """
    logger.info(f"ðŸš¦ Validating {len(payloads)} payloads on {url}...")
    confirmed = []

    headers = {
        "User-Agent": "Chosenbrain-BBH-Validator/1.0"
    }

    for full_url in payloads:
        try:
            r = requests.get(full_url, headers=headers, timeout=10)
            for pattern in TRIGGERS:
                if re.search(pattern, r.text, re.IGNORECASE):
                    logger.warning(f"âœ… Confirmed exploit: {full_url}")
                    confirmed.append({
                        "url": full_url,
                        "trigger": pattern
                    })
                    break
        except requests.RequestException as e:
            logger.debug(f"Request error: {e}")

    return confirmed
